{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment polynomialsz  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0.0 \par
}}polynomialsz}
{\comment Generated by doxygen 1.13.2.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt polynomialsz}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b polynomial} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a polynomial as an array of terms })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b spolynomial} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b sterm} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b term} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a single term in a polynomial })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/{\b polynomialsz.c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source file for polynomial factorization functionalities })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/{\b polynomialsz.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for polynomial factorization structures })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
polynomial Struct Reference\par \pard\plain 
{\tc\tcl2 \v polynomial}
{\xe \v polynomial}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a polynomial as an array of terms. }}\par
{
{\f2 #include <polynomialsz.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a polynomial as an array of terms. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The terms are not required to be sorted, but usually are ordered by descending exponents. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/{\b polynomialsz.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
spolynomial Struct Reference\par \pard\plain 
{\tc\tcl2 \v spolynomial}
{\xe \v spolynomial}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\par
{
{\f2 #include <polynomialsz.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b term} * {\b terms}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b num_of_terms}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v num_of_terms\:spolynomial}
{\xe \v spolynomial\:num_of_terms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int num_of_terms}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of terms in the polynomial. \par
}}
{\xe \v terms\:spolynomial}
{\xe \v spolynomial\:terms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b term}* terms}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dynamic array of polynomial terms. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/{\b polynomialsz.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sterm Struct Reference\par \pard\plain 
{\tc\tcl2 \v sterm}
{\xe \v sterm}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
{
{\f2 #include <polynomialsz.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b coefficient}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exponent}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v coefficient\:sterm}
{\xe \v sterm\:coefficient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int coefficient}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The coefficient of the term. \par
}}
{\xe \v exponent\:sterm}
{\xe \v sterm\:exponent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int exponent}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The exponent of the term. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/{\b polynomialsz.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
term Struct Reference\par \pard\plain 
{\tc\tcl2 \v term}
{\xe \v term}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a single term in a polynomial. }}\par
{
{\f2 #include <polynomialsz.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Represents a single term in a polynomial. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A term is composed of a coefficient and an exponent. For example, the term 3x\'B2 has coefficient = 3 and exponent = 2. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/{\b polynomialsz.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/polynomialsz.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/polynomialsz.c}
{\xe \v C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/polynomialsz.c}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source file for polynomial factorization functionalities. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "polynomialsz.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b term} {\b setTerms} (int coef, int exp)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates and sets the coefficient and exponent of a polynomial term. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b nrt} (double rad, int ind)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the base of a power with an exponent equal to ind, which equals to rad. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b indOfRoot} (int rad, double rt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the exponent (index) of a power that has base rt and result rad. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b polynomial} {\b pCreate} (int num_of_terms)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates and returns a polynomial with a specified number of terms. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pPrint} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the polynomial. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gcd} (int a, int b)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the greatest common divisor (GCD) of two integers using the Euclidean algorithm. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isPrime} (int num)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the n-th isPrime number, where n is less than or equal to 41. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b eisenstein} ({\b polynomial} x, double p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies Eisenstein's criterion to determine whether a polynomial is irreducible. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b complexp} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all non-real complex roots of a polynomial, assuming unit modulus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b bhaskaraSimplify} (int aexp, int den, int b, double delta, double *rootsPair)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates a symbolic factorized string representation of a second-degree polynomial. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bhaskara} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates and prints the factorization of a second-degree polynomial using the Bhaskara (quadratic) formula. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b powerDiffFactoring} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the sum or difference of powers identity (a^n \'B1 b^n). For odd n, both sum and difference can be factorized. For even n, only the difference can be factorized. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b briot_ruffini} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to factor a polynomial using the Rational Root Theorem and synthetic division. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printFac} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the factorization of a polynomial or displays the appropriate message based on the type of factorization that can be performed on it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pFree} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unlike {\f2 {\b printFac()}} , this alternative also deallocates the polynomial's terms memory using {\f2 free(p.terms)} . }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b var} = 'x'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbolic variable used to represent roots and polynomial expressions. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source file for polynomial factorization functionalities. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file implements the core logic for factoring polynomials, including algorithms such as Briot-Ruffini, Eisenstein's Criterion, and power difference factoring. It uses the data structures and declarations defined in the corresponding header file ({\b polynomialsz.h}). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bhaskara\:polynomialsz.c}
{\xe \v polynomialsz.c\:bhaskara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bhaskara ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates and prints the factorization of a second-degree polynomial using the Bhaskara (quadratic) formula. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function simplifies the result depending on the values \'E2\'80\'8B\'E2\'80\'8Bof "b" and delta.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{A polynomial of degree 2 or 4 with three terms in descending order of exponent. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 351                             \{\par
352 \par
353     {\cf18 int} aexp = p.terms[0].exponent;\par
354     {\cf18 int} a = p.terms[0].coefficient;\par
355     {\cf18 int} b = p.terms[1].coefficient;\par
356     {\cf18 int} c = p.terms[2].coefficient;\par
357 \par
358     {\cf18 int} den = 2 * a;\par
359     {\cf18 double} delta = pow(b, 2) - (4 * a * c);\par
360     {\cf18 double} rootsPair[2] = \{0, 0\};\par
361 \par
362     rootsPair[0] = (-b + (sqrt((fabs)(delta)))) / den;\par
363     rootsPair[1] = (-b - (sqrt((fabs)(delta)))) / den;\par
364 \par
365     {\cf18 int} asbRoot1 = (int)(fabs)(rootsPair[0]);\par
366     {\cf18 int} asbRoot2 = (int)(fabs)(rootsPair[1]);\par
367 \par
368     {\cf18 char}* bSimplify = bhaskaraSimplify(aexp, den, b, delta, rootsPair);\par
369 \par
370     {\cf18 int} negRoot = (rootsPair[0] <= 0 || rootsPair[1] <= 0 || (aexp == 4 && delta >= 0)) ? 1 : -1;\par
371 \par
372     {\cf19 if}(negRoot == 1)\{\par
373 \par
374         printf({\cf22 "%s"}, bSimplify);\par
375     \}\par
376     {\cf19 else} {\cf19 if}(aexp == 4)\{\par
377 \par
378         printf({\cf22 "(%c%c%i)(%c%c%i)(%c%c%i)(%c%c%i)"}, var, (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, asbRoot1,\par
379                                                    var, (rootsPair[0] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, asbRoot1,\par
380                                                    var, (rootsPair[1] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, asbRoot2,\par
381                                                    var, (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, asbRoot2);\par
382     \}\par
383     {\cf19 else}\{\par
384 \par
385         printf({\cf22 "(%c%c%i)(%c%c%i)"}, var, (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, asbRoot1,\par
386                                    var, (rootsPair[1] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, asbRoot2);\par
387     \}\par
388 \par
389     free(bSimplify);\par
390 \}\par
}
}
{\xe \v bhaskaraSimplify\:polynomialsz.c}
{\xe \v polynomialsz.c\:bhaskaraSimplify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * bhaskaraSimplify (int aexp, int den, int b, double delta, double * rootsPair)}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates a symbolic factorized string representation of a second-degree polynomial. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function receives the coefficients and discriminant of a quadratic equation and returns a heap-allocated string with a symbolic factorization of its roots. It handles various cases, including:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Real and rational roots\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Irrational roots (containing square roots)\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Complex conjugate roots\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Pure imaginary roots\par}
It also supports optional squaring of the variable (e.g., x^2) if the polynomial is a square of a quadratic term (useful for degree 4 cases).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The returned string is dynamically allocated using {\f2 malloc()}  and must be freed by the caller to avoid memory leaks.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i aexp} \cell }{The exponent of the leading term (typically 2 or 4). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i den} \cell }{The denominator used to normalize the roots (usually 2 * a). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{The coefficient of the linear term in the polynomial. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i delta} \cell }{The discriminant value (b\'B2 - 4ac) of the polynomial. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rootsPair} \cell }{A pointer to an array of two doubles representing the numeric roots (used for formatting).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to a dynamically allocated string containing the symbolic factorization. The string must be freed manually by the caller. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 239                                                                                  \{\par
240 \par
241     {\cf18 int} absDelta = (int)(fabs)(delta);\par
242     {\cf18 char}* bSimplify = malloc({\cf17 sizeof}({\cf18 char}) * 60);\par
243     {\cf18 char} powerRoot[3] = {\cf22 ""};\par
244 \par
245     {\cf19 if}(aexp == 4)\{\par
246 \par
247         snprintf(powerRoot, 3, {\cf22 "^2"});\par
248     \}\par
249 \par
250     {\cf19 if}(({\cf18 int})sqrt(absDelta) * ({\cf18 int})sqrt(absDelta) == absDelta)\{\par
251 \par
252         {\cf19 if}(delta >= 0)\{\par
253 \par
254             {\cf19 if}((-b + ({\cf18 int})sqrt(absDelta)) % den == 0)\{\par
255 \par
256                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c %i)(%c%s %c %i)"}, var, powerRoot,\par
257                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, (-b + ({\cf18 int})sqrt(absDelta))/den, var, powerRoot,\par
258                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, (-b + ({\cf18 int})sqrt(absDelta))/den);\par
259             \}\par
260             {\cf19 else} {\cf19 if}((-b + ({\cf18 int})sqrt(absDelta)) % den != 0 && b != 0)\{\par
261 \par
262                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i + %i)/%i)(%c%s %c (%i - %i)/%i)"}, var, powerRoot,\par
263                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b, ({\cf18 int})sqrt(absDelta), den, var, powerRoot,\par
264                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b, ({\cf18 int})sqrt(absDelta), den);\par
265             \}\par
266             {\cf19 else}\{\par
267 \par
268                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i/%i))(%c%s %c (%i/i))"}, var, powerRoot,\par
269                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, ({\cf18 int})sqrt(absDelta), den, var, powerRoot,\par
270                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, ({\cf18 int})sqrt(absDelta), den);\par
271             \}\par
272         \}\par
273         {\cf19 else}\{\par
274             {\cf19 if}(-b % den == 0 && ({\cf18 int})sqrt(absDelta) % den == 0 && ({\cf18 int})sqrt(absDelta) / den != 1 && b != 0)\{\par
275 \par
276                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i + i%i))(%c%s %c (%i - i%i))"}, var, powerRoot,\par
277                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b/den, ({\cf18 int})sqrt(absDelta)/den, var, powerRoot,\par
278                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b/den, ({\cf18 int})sqrt(absDelta)/den);\par
279             \}\par
280             {\cf19 else} {\cf19 if}(-b % den == 0 && ({\cf18 int})sqrt(absDelta) % den == 0 && b != 0)\{\par
281 \par
282                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i + i))(%c%s %c (%i - i))"}, var, powerRoot,\par
283                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b/den, var, powerRoot,\par
284                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b/den);\par
285             \}\par
286 \par
287             {\cf19 else} {\cf19 if}(-b % den != 0 || ({\cf18 int})sqrt(absDelta) % den != 0 && b != 0)\{\par
288 \par
289                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i + i%i)/%i)(%c%s %c (%i - i%i)/%i)"}, var, powerRoot,\par
290                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b, ({\cf18 int})sqrt(absDelta), den, var, powerRoot,\par
291                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b, ({\cf18 int})sqrt(absDelta), den);\par
292             \}\par
293             {\cf19 else} {\cf19 if}(({\cf18 int})sqrt(absDelta) % den == 0 && ({\cf18 int})sqrt(absDelta) / den != 1 && b == 0)\{\par
294 \par
295                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c i%i)(%c%s %c i%i)"}, var, powerRoot,\par
296                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, ({\cf18 int})sqrt(absDelta)/den, var, powerRoot,\par
297                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, ({\cf18 int})sqrt(absDelta)/den);\par
298             \}\par
299             {\cf19 else} {\cf19 if}(({\cf18 int})sqrt(absDelta) % den == 0 && b == 0)\{\par
300 \par
301                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c i)(%c%s %c i)"}, var, powerRoot,\par
302                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, var, powerRoot,\par
303                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'});\par
304             \}\par
305             {\cf19 else}\{\par
306 \par
307                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c i%i/%i)(%c%s %c i%i/%i)"}, var, powerRoot,\par
308                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, ({\cf18 int})sqrt(absDelta), den, var, powerRoot,\par
309                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, ({\cf18 int})sqrt(absDelta), den);\par
310             \}\par
311         \}\par
312     \}\par
313     {\cf19 else}\{\par
314         {\cf19 if}(delta >= 0)\{\par
315 \par
316             {\cf19 if}(b != 0)\{\par
317 \par
318                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c ((%i + %i^\{1/2\})/%i)) (%c%s %c ((%i - %i^\{1/2\})/%i))"}, var, powerRoot,\par
319                (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b, absDelta, den, var, powerRoot,\par
320                (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b, absDelta, den);\par
321             \}\par
322             {\cf19 else}\{\par
323 \par
324                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i^\{1/2\})/%i) (%c%s %c (%i^\{1/2\})/%i)"}, var, powerRoot,\par
325                (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, absDelta, den, var, powerRoot,\par
326                (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, absDelta, den);\par
327             \}\par
328         \}\par
329         {\cf19 else}\{\par
330 \par
331             {\cf19 if}(b != 0)\{\par
332 \par
333                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c ((%i + i%i^\{1/2\})/%i)) (%c%s %c ((%i - i%i^\{1/2\})/%i))"}, var, powerRoot,\par
334                (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b, absDelta, den, var, powerRoot,\par
335                (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b, absDelta, den);\par
336             \}\par
337             {\cf19 else}\{\par
338 \par
339                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (i%i^\{1/2\})/%i) (%c%s %c (i%i^\{1/2\})/%i)"}, var, powerRoot,\par
340                (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, absDelta, den, var, powerRoot,\par
341                (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, absDelta, den);\par
342             \}\par
343         \}\par
344     \}\par
345 \par
346     {\cf19 return} bSimplify;\par
347 \}\par
}
}
{\xe \v briot_ruffini\:polynomialsz.c}
{\xe \v polynomialsz.c\:briot_ruffini}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void briot_ruffini ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to factor a polynomial using the Rational Root Theorem and synthetic division. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies Briot\'96Ruffini's method (synthetic division) to find integer and rational roots of a polynomial, as well as approximated square root roots when possible. Displays factored linear and radical terms.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial to be factored. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 433                                 \{\par
434 \par
435     {\cf18 int} max_num = 0, start = 1, i = 1, r = 1, rq = 0, end_int = 0, rnum = 1, rI = 1, cont = 1;\par
436     {\cf18 double} ind = 1, startf = 1;\par
437 \par
438     {\cf18 int} *root = ({\cf18 int}*)calloc(p.num_of_terms, {\cf17 sizeof}({\cf18 int}));\par
439 \par
440     {\cf19 for} ({\cf18 int} j = 1; j < p.num_of_terms; j++) \{\par
441         max_num = (p.terms[j].coefficient > max_num) ? p.terms[j].coefficient : max_num;\par
442     \}\par
443 \par
444     {\cf19 while} (i != max_num) \{\par
445 \par
446         start = i * 1 + p.terms[1].coefficient;\par
447 \par
448         {\cf19 for} ({\cf18 int} k = 2; k < p.num_of_terms; k++) \{\par
449             start = i * start + p.terms[k].coefficient;\par
450         \}\par
451 \par
452         {\cf19 if} (start == 0) \{\par
453             root[r] = i;\par
454             r++;\par
455         \}\par
456 \par
457         i++;\par
458     \}\par
459 \par
460     {\cf19 if} (r < p.num_of_terms) \{\par
461         i = -max_num;\par
462 \par
463         {\cf19 while} (i != 0) \{\par
464             start = i * 1 + p.terms[1].coefficient;\par
465 \par
466             {\cf19 for} ({\cf18 int} k = 2; k < p.num_of_terms; k++) \{\par
467                 start = i * start + p.terms[k].coefficient;\par
468             \}\par
469 \par
470             {\cf19 if} (start == 0) \{\par
471                 root[r] = i;\par
472                 r++;\par
473             \}\par
474 \par
475             i++;\par
476         \}\par
477     \}\par
478 \par
479     end_int = r;\par
480 \par
481     {\cf19 if} (r < p.num_of_terms) \{\par
482         rq = 2;\par
483 \par
484         {\cf19 while} (rq < max_num && r < p.num_of_terms) \{\par
485 \par
486             ind = sqrt(rq);\par
487             startf = ind + p.terms[1].coefficient;\par
488 \par
489             {\cf19 for} ({\cf18 int} k = 2; k <= p.num_of_terms; k++) \{\par
490                 startf = ind * startf + p.terms[k].coefficient;\par
491 \par
492                 {\cf19 if} (({\cf18 int})(startf * 1000) == 0) \{\par
493                     root[r] = rq;\par
494                     root[r + 1] = rq;\par
495                     r += 2;\par
496                     {\cf19 break};\par
497                 \}\par
498             \}\par
499 \par
500             rq++;\par
501 \par
502             {\cf19 for} ({\cf18 int} rr = 0; rr < end_int; rr++) \{\par
503                 {\cf19 if}(root[rr] == sqrt(rq)) \{\par
504                     rq++;\par
505                 \}\par
506             \}\par
507         \}\par
508     \}\par
509 \par
510     {\cf18 int} pr = 0;\par
511 \par
512     {\cf19 if} (r != p.num_of_terms-1) \{\par
513         {\cf19 for} ({\cf18 int} l = 1; root[l] != 0 && l < p.num_of_terms; l++) \{\par
514 \par
515             {\cf19 if} (l < end_int) \{\par
516                 printf({\cf22 "(%c%c%d)"}, var, ((root[l] > 0) ? {\cf23 '-'} : {\cf23 '+'}), abs(root[l]));\par
517                 pr++;\par
518             \}\par
519             {\cf19 else} {\cf19 if} (l >= end_int && p.terms[0].exponent != 3) \{\par
520                 printf({\cf22 "(%c + %d^\{1/2\})(%c - %d^\{1/2\})"}, var, root[l], var, root[l]);\par
521                 l++;\par
522                 pr++;\par
523             \}\par
524             {\cf19 if} (rq > 0 && p.terms[0].exponent % 2 != 0 && p.terms[0].exponent < 6 && (p.terms[p.num_of_terms - 1].coefficient >= 0))\{\par
525 \par
526                 {\cf18 int} px = (p.terms[0].exponent == 3) ? p.terms[1].coefficient + root[1] : p.terms[3].coefficient / -root[1];\par
527                 {\cf18 int} qx = (p.terms[0].exponent == 3) ? p.terms[2].coefficient + px*root[1] : p.terms[5].coefficient / -root[1];\par
528 \par
529                 polynomial aux = pCreate(3);\par
530                 aux.terms[0] = setTerms(1, p.terms[0].exponent - 1);\par
531                 aux.terms[1] = setTerms(px, p.terms[0].exponent / 2);\par
532                 aux.terms[2] = setTerms(qx, 0);\par
533 \par
534                 bhaskara(aux);\par
535                 printf({\cf22 "\\n\\n"});\par
536                 {\cf19 return};\par
537             \}\par
538         \}\par
539     \}\par
540 \par
541     {\cf19 if}(pr == 0)\{\par
542 \par
543         printf({\cf22 "There is no non-imaginary factorization and/or no root representable by radicals or integers for this polynomial.\\n\\n"});\par
544         free(root);\par
545         {\cf19 return};\par
546     \}\par
547 \par
548     printf({\cf22 ";\\n\\n"});\par
549     free(root);\par
550     {\cf19 return};\par
551 \}\par
}
}
{\xe \v complexp\:polynomialsz.c}
{\xe \v polynomialsz.c\:complexp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void complexp ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all non-real complex roots of a polynomial, assuming unit modulus. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function assumes that the polynomial has only complex roots located on the unit circle and calculates the complex roots in exponential form e^\{i\'CE\'B8\} and e^\{-i\'CE\'B8\}, where \'CE\'B8 is an angle in radians represented as a multiple of \'CF\'80. It handles both cases when the polynomial is monic or not and adjusts the number of printed roots accordingly.\par
The roots are displayed using Euler's formula and shown as factorized expressions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial from which the complex roots will be extracted and printed. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 150                             \{\par
151 \par
152     {\cf18 double} angle = 0;\par
153     {\cf18 int} numerator = 0;\par
154     {\cf18 int} den = 1;\par
155 \par
156     {\cf19 for}({\cf18 int} l = 0; l < p.num_of_terms; l++)\{\par
157 \par
158         den *= p.terms[l].coefficient;\par
159     \}\par
160 \par
161     {\cf18 int} degree = (den == 1) ? p.num_of_terms : p.terms[0].exponent;\par
162 \par
163     {\cf18 int} total_roots = (degree % 2 == 0) ? degree - 1 : degree;\par
164 \par
165     {\cf19 if}(den != 1) total_roots++;\par
166 \par
167     {\cf18 int} common_divisor = 0;\par
168 \par
169     {\cf19 if} (degree % 2 == 0) \{\par
170         printf({\cf22 "(%c + 1)"}, var);\par
171     \}\par
172 \par
173     {\cf19 if} (den == 1)\{\par
174 \par
175         {\cf19 for} ({\cf18 int} k = 1; k <= total_roots / 2; k++) \{\par
176 \par
177             den = degree;\par
178             angle = 2 * M_PI * k / degree;\par
179             numerator = 2 * k;\par
180             common_divisor = gcd(numerator, den);\par
181 \par
182             numerator /= common_divisor;\par
183             den /= common_divisor;\par
184 \par
185             {\cf18 char} angle_str[50];\par
186 \par
187             {\cf19 if} (den == 1)\{\par
188                 snprintf(angle_str, 50, {\cf22 "%i*pi"}, numerator);\par
189             \}\par
190             {\cf19 else} {\cf19 if} (numerator == 1)\{\par
191                 snprintf(angle_str, 50, {\cf22 "*pi/%i"}, den);\par
192             \}\par
193             {\cf19 else}\{\par
194                 snprintf(angle_str, 50, {\cf22 "%i*pi/%i"}, numerator, den);\par
195             \}\par
196 \par
197             {\cf19 if}(den == 2 && numerator == 1)\{\par
198 \par
199                 printf({\cf22 "(%c - i)"}, var);\par
200                 printf({\cf22 "(%c + i)"}, var);\par
201                 {\cf19 return};\par
202             \}\par
203 \par
204             printf({\cf22 "(%c - e^\{i%s\})"}, var, angle_str);\par
205             printf({\cf22 "(%c - e^\{-i%s\})"}, var, angle_str);\par
206         \}\par
207     \}\par
208     {\cf19 else}\{\par
209 \par
210         {\cf19 for} ({\cf18 int} k = 0; k < p.terms[0].exponent; k++) \{\par
211 \par
212             den = degree;\par
213             numerator = (2 * k) + 1;\par
214             common_divisor = gcd(numerator, den);\par
215 \par
216             numerator /= common_divisor;\par
217             den /= common_divisor;\par
218 \par
219             {\cf18 char} angle_str[50];\par
220 \par
221             {\cf19 if} (den == 1)\{\par
222                 snprintf(angle_str, 50, {\cf22 "%i*pi"}, numerator);\par
223             \}\par
224             {\cf19 else} {\cf19 if} (numerator == 1)\{\par
225                 snprintf(angle_str, 50, {\cf22 "*pi/%i"}, den);\par
226             \}\par
227             {\cf19 else}\{\par
228                 snprintf(angle_str, 50, {\cf22 "%i*pi/%i"}, numerator, den);\par
229             \}\par
230 \par
231             {\cf19 if}(numerator != den) printf({\cf22 "(%c - e^\{i%s\})"}, var, angle_str);\par
232             {\cf19 else} printf({\cf22 "(%c + 1)"}, var);\par
233         \}\par
234     \}\par
235 \}\par
}
}
{\xe \v eisenstein\:polynomialsz.c}
{\xe \v polynomialsz.c\:eisenstein}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int eisenstein ({\b polynomial} x, double p)}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies Eisenstein's criterion to determine whether a polynomial is irreducible. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the polynomial satisfies the conditions of Eisenstein's Criterion for irreducibility using the isPrime number p. According to the criterion, all coefficients except the leading one must be divisible by p, and the constant term must not be divisible by p^2.\par
Although Eisenstein's Criterion is a powerful tool, it has limitations \'97 for example, the polynomial (x^4 + 1) is irreducible over the rationals, despite not satisfying the criterion.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{The polynomial to be tested. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{A isPrime number used for the Eisenstein's test. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
1 if the polynomial is irreducible by Eisenstein's criterion, -1 otherwise. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 127                                       \{\par
128 \par
129     {\cf18 int} irr = 1;\par
130 \par
131     {\cf19 for}({\cf18 int} i = 1; i < x.num_of_terms; i++)\{\par
132 \par
133         irr = (x.terms[i].coefficient % (int)p == 0) ? irr * 1 : 0;\par
134     \}\par
135 \par
136     {\cf19 if}(x.terms[x.num_of_terms - 1].coefficient % ({\cf18 int})pow(p, 2) != 0)\par
137         irr *= 1;\par
138     {\cf19 else}\par
139         irr = 0;\par
140 \par
141 \par
142     {\cf19 if}(irr == 1)\par
143         {\cf19 return} 1;\par
144     {\cf19 else}\par
145         {\cf19 return} -1;\par
146 \}\par
}
}
{\xe \v gcd\:polynomialsz.c}
{\xe \v polynomialsz.c\:gcd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int gcd (int a, int b)}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the greatest common divisor (GCD) of two integers using the Euclidean algorithm. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{The first integer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{The second integer. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The greatest common divisor of a and b. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 94                       \{\par
95 \par
96     {\cf19 if}(b == 0)\par
97         {\cf19 return} a;\par
98 \par
99     {\cf19 return} gcd(b, a % b);\par
100 \}\par
}
}
{\xe \v indOfRoot\:polynomialsz.c}
{\xe \v polynomialsz.c\:indOfRoot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int indOfRoot (int rad, double rt)}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the exponent (index) of a power that has base rt and result rad. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rad} \cell }{The radicand (power's result). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rt} \cell }{The root (power's base). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
ind The index (power's exponent). \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                  \{\par
43 \par
44     {\cf18 int} ind = 1;\par
45 \par
46     {\cf19 while}(({\cf18 int})pow(rt, ind) != (fabs)(rad))\{\par
47         ind++;\par
48     \}\par
49 \par
50     {\cf19 return} ind;\par
51 \}\par
}
}
{\xe \v isPrime\:polynomialsz.c}
{\xe \v polynomialsz.c\:isPrime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int isPrime (int num)}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the n-th isPrime number, where n is less than or equal to 41. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function only supports values of n up to 41 because the 41st isPrime number is 179, which is the largest isPrime whose square (179^2 = 32,041) still fits within a 32-bit signed integer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The position of the isPrime number to return (must be \'E2\'89\'A4 41). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The n-th isPrime number, or 0 if num > 41. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103                     \{\par
104 \par
105     {\cf19 if}(num > 41)\par
106         {\cf19 return} 0;\par
107 \par
108     {\cf18 int} i = 2;\par
109     {\cf18 int} pcont = 0;\par
110     {\cf18 int} dcont = 0;\par
111 \par
112     {\cf19 for}(i = 2; i < 180 && pcont != num; i++)\{\par
113 \par
114         {\cf19 for}({\cf18 int} k = 1; k <= i; k++)\{\par
115 \par
116             dcont = (i % k == 0) ? dcont + 1 : dcont;\par
117         \}\par
118         pcont = (dcont == 2) ? pcont + 1 : pcont;\par
119         dcont = 0;\par
120     \}\par
121 \par
122     {\cf19 return} i - 1;\par
123 \}\par
}
}
{\xe \v nrt\:polynomialsz.c}
{\xe \v polynomialsz.c\:nrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double nrt (double rad, int ind)}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the base of a power with an exponent equal to ind, which equals to rad. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rad} \cell }{The radicand (power's result). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ind} \cell }{The index (power's exponent). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
base The base (radical's result). \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 33                                \{\par
34 \par
35     {\cf18 double} base = (pow((fabs)(rad), 1.0/({\cf18 double})(ind)));\par
36 \par
37     {\cf19 return} base;\par
38 \}\par
}
}
{\xe \v pCreate\:polynomialsz.c}
{\xe \v polynomialsz.c\:pCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b polynomial} pCreate (int num_of_terms)}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates and returns a polynomial with a specified number of terms. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function allocates memory for a polynomial structure and initializes its internal array of terms based on the specified number of terms. It is used as a starting point for defining or manipulating polynomials.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num_of_terms} \cell }{The number of terms the polynomial should contain. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A polynomial structure with allocated space for the specified number of terms. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55                                      \{\par
56 \par
57     {\cf18 int} j = 0;\par
58     polynomial p;\par
59     p.num_of_terms = num_of_terms;\par
60     p.terms = (term*)malloc(num_of_terms * {\cf17 sizeof}(term));\par
61 \par
62     {\cf19 if}(p.terms == NULL)\{\par
63 \par
64         printf({\cf22 "\\nError allocating memory."});\par
65         {\cf19 return} p;\par
66     \}\par
67 \par
68     {\cf19 for}({\cf18 int} i = num_of_terms-1; i >= 0; i--)\{\par
69 \par
70         p.terms[j].coefficient = 0;\par
71         p.terms[j].exponent = i;\par
72         j++;\par
73     \}\par
74 \par
75     {\cf19 return} p;\par
76 \}\par
}
}
{\xe \v pFree\:polynomialsz.c}
{\xe \v polynomialsz.c\:pFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pFree ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unlike {\f2 {\b printFac()}} , this alternative also deallocates the polynomial's terms memory using {\f2 free(p.terms)} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial to be factored. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 632                          \{\par
633 \par
634     {\cf18 int} check_coefficient = (p.num_of_terms > 2 && p.terms[p.num_of_terms - 1].coefficient == 1) ? 1 : 0;\par
635 \par
636     {\cf19 for} ({\cf18 int} j = 0; j < p.num_of_terms; j++) \{\par
637         check_coefficient = ((p.terms[j].coefficient) == -1) ? (check_coefficient + 2) : check_coefficient;\par
638         check_coefficient = ((p.terms[j].coefficient) == 1) ? (check_coefficient * check_coefficient) : check_coefficient;\par
639     \}\par
640 \par
641     {\cf18 int} irrdcble = 0;\par
642 \par
643     {\cf19 for} ({\cf18 int} i = 1; i < 42 && irrdcble != 1; i++) \{\par
644         irrdcble = eisenstein(p, isPrime(i));\par
645     \}\par
646 \par
647     {\cf19 if} (irrdcble == 1 && p.num_of_terms >= 5 && ((p.num_of_terms % 2 == 0 && p.terms[p.num_of_terms - 1].coefficient > 0)\par
648         || p.num_of_terms % 2 != 0 && p.terms[p.num_of_terms - 1].coefficient < 0) || irrdcble == -1 && p.num_of_terms >= 5 && check_coefficient > 1)\{\par
649 \par
650         printf({\cf22 "There is no non-imaginary factorization and/or no root representable by radicals or integers for this polynomial.\\n\\n"});\par
651         free(p.terms);\par
652 \par
653         {\cf19 return};\par
654     \} {\cf19 else} \{\par
655 \par
656         {\cf19 if} (p.num_of_terms == 2 && p.terms[0].exponent == indOfRoot(p.terms[1].coefficient, (nrt(p.terms[1].coefficient, p.terms[0].exponent)))) \{\par
657 \par
658             {\cf19 if} ((p.terms[1].coefficient < 0 && p.terms[0].exponent % 2 == 0) || p.terms[0].exponent % 2 != 0) \{\par
659 \par
660                 powerDiffFactoring(p);\par
661 \par
662                 {\cf19 if} (check_coefficient == 1) complexp(p);\par
663 \par
664                 free(p.terms);\par
665 \par
666                 printf({\cf22 ";\\n\\n"});\par
667                 {\cf19 return};\par
668             \}\par
669         \}\par
670 \par
671         {\cf19 if} (p.terms[0].exponent % 2 == 0 && p.num_of_terms < 5 && p.terms[1].exponent != 3) \{\par
672 \par
673             bhaskara(p);\par
674 \par
675             free(p.terms);\par
676 \par
677             printf({\cf22 ";\\n\\n"});\par
678             {\cf19 return};\par
679         \}\par
680 \par
681         {\cf19 if} (check_coefficient != 1) briot_ruffini(p);\par
682 \par
683         {\cf19 if} (check_coefficient == 1)\{\par
684 \par
685             complexp(p);\par
686             printf({\cf22 ";\\n\\n"});\par
687         \}\par
688 \par
689         free(p.terms);\par
690 \par
691         {\cf19 return};\par
692     \}\par
693 \par
694     free(p.terms);\par
695 \}\par
}
}
{\xe \v powerDiffFactoring\:polynomialsz.c}
{\xe \v polynomialsz.c\:powerDiffFactoring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void powerDiffFactoring ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the sum or difference of powers identity (a^n \'B1 b^n). For odd n, both sum and difference can be factorized. For even n, only the difference can be factorized. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assumes the polynomial is in the form x^n \'B1 a and prints the factorization steps based on the formula. Handles both even and odd exponents.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial to be factored. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 394                                      \{\par
395 \par
396     {\cf18 int} i = p.terms[0].exponent - 1, even_num = 1;\par
397     {\cf18 int} count = 1;\par
398     {\cf18 double} a = (nrt(p.terms[1].coefficient, p.terms[0].exponent));\par
399 \par
400     printf({\cf22 "(%c%c%i)"}, var, (p.terms[1].coefficient < 0) ? {\cf23 '-'} : {\cf23 '+'}, ({\cf18 int})a);\par
401 \par
402     {\cf19 if}(p.terms[0].exponent % 2 == 0)\{\par
403         printf({\cf22 "(%c%c%i)"}, var, (p.terms[1].coefficient < 0) ? {\cf23 '+'} : {\cf23 '-'}, ({\cf18 int})a);\par
404         even_num++;\par
405     \}\par
406 \par
407     {\cf19 if}(p.terms[0].exponent < 2)\{\par
408         {\cf19 return};\par
409     \}\par
410 \par
411     printf({\cf22 "(%c^\{%i\}"}, var, (even_num == 2) ? --i : i);\par
412 \par
413     {\cf19 while}(i - even_num > 0)\{\par
414         printf({\cf22 " %c %i%c^\{%i\}"},\par
415                (p.terms[1].coefficient > 0 && i % 2 == 0) ? {\cf23 '-'} : {\cf23 '+'},\par
416                (even_num == 2) ? ({\cf18 int})(pow(a, ++count)) : ({\cf18 int})(pow(a, count++)),\par
417                var, i - even_num);\par
418 \par
419         {\cf19 if}(even_num == 2)\{\par
420             i = i - even_num;\par
421             count++;\par
422         \}\par
423         {\cf19 else} i--;\par
424     \}\par
425 \par
426     printf({\cf22 " + %i)"}, ({\cf18 int})(pow(a, p.terms[0].exponent - even_num)));\par
427 \par
428     {\cf19 return};\par
429 \}\par
}
}
{\xe \v pPrint\:polynomialsz.c}
{\xe \v polynomialsz.c\:pPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pPrint ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the polynomial. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 80                          \{\par
81 \par
82     printf({\cf22 "(%i%c^%i"}, p.terms[0].coefficient, var, p.terms[0].exponent);\par
83 \par
84     {\cf19 for}({\cf18 int} i = 1; i < p.num_of_terms; i++)\{\par
85 \par
86         printf({\cf22 "%c%i%c^%i"}, (p.terms[i].coefficient >= 0) ? {\cf23 '+'} : {\cf23 '-'}, (abs)(p.terms[i].coefficient), var, p.terms[i].exponent);\par
87     \}\par
88 \par
89     printf({\cf22 ")\\n\\n"});\par
90 \}\par
}
}
{\xe \v printFac\:polynomialsz.c}
{\xe \v polynomialsz.c\:printFac}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printFac ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the factorization of a polynomial or displays the appropriate message based on the type of factorization that can be performed on it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function evaluates a polynomial to determine the appropriate factorization technique:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
If the polynomial is irreducible based on Eisenstein's criterion, it outputs a message indicating that there is no non-imaginary factorization or roots representable by radicals.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
If the polynomial is a quadratic, it applies potential difference factoring, if applicable.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
If the polynomial has an even degree and three or fewer terms, it applies the Bhaskara method.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
If the polynomial does not meet any of the above criteria, it attempts Briot-Ruffini's method or performs complex factorization if needed.\par}
The function handles polynomials with a varying number of terms and coefficients, including checking for special cases such as unique coefficients and evaluating Eisenstein's criterion.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial to be factored. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 555                             \{\par
556 \par
557     {\cf18 int} check_coefficient = (p.num_of_terms > 2 && p.terms[p.num_of_terms - 1].coefficient == 1) ? 1 : 0;\par
558 \par
559     {\cf19 for} ({\cf18 int} j = 0; j < p.num_of_terms; j++) \{\par
560         check_coefficient = ((p.terms[j].coefficient) == -1) ? (check_coefficient + 2) : check_coefficient;\par
561         check_coefficient = ((p.terms[j].coefficient) == 1) ? (check_coefficient * check_coefficient) : check_coefficient;\par
562     \}\par
563 \par
564     {\cf18 int} irrdcble = 0;\par
565 \par
566     {\cf19 for} ({\cf18 int} i = 1; i < 42 && irrdcble != 1; i++) \{\par
567         irrdcble = eisenstein(p, isPrime(i));\par
568     \}\par
569 \par
570     {\cf20 /*}\par
571 {\cf20      * This condition checks if the polynomial meets one of two criteria:}\par
572 {\cf20      *}\par
573 {\cf20      * 1. The polynomial is irreducible, has 5 or more terms, and satisfies one of the following:}\par
574 {\cf20      *    - The highest degree is even, and the constant term (last coefficient) is positive.}\par
575 {\cf20      *    - The highest degree is odd, and the constant term is negative.}\par
576 {\cf20      *}\par
577 {\cf20      * 2. The polynomial is not irreducible (irrdcble == -1), has 5 or more terms, and its coefficient check value (check_coefficient) is greater than 1.}\par
578 {\cf20      *    This implies the polynomial may not follow a simple factorization or progression pattern.}\par
579 {\cf20      *}\par
580 {\cf20      * If either of these conditions is met, the function prints a message indicating that}\par
581 {\cf20      * no non-imaginary factorization and/or no root representable by radicals or integers}\par
582 {\cf20      * is possible for the polynomial, and the function returns.}\par
583 {\cf20      */}\par
584     {\cf19 if} (irrdcble == 1 && p.num_of_terms >= 5 && ((p.num_of_terms % 2 == 0 && p.terms[p.num_of_terms - 1].coefficient > 0)\par
585         || p.num_of_terms % 2 != 0 && p.terms[p.num_of_terms - 1].coefficient < 0) || irrdcble == -1 && p.num_of_terms >= 5 && check_coefficient > 1)\{\par
586 \par
587         printf({\cf22 "There is no non-imaginary factorization and/or no root representable by radicals or integers for this polynomial.\\n\\n"});\par
588 \par
589         {\cf19 return};\par
590     \} {\cf19 else} \{\par
591         {\cf20 // Handle case for a quadratic polynomial}\par
592         {\cf19 if} (p.num_of_terms == 2 && p.terms[0].exponent == indOfRoot(p.terms[1].coefficient, (nrt(p.terms[1].coefficient, p.terms[0].exponent)))) \{\par
593 \par
594             {\cf19 if} ((p.terms[1].coefficient < 0 && p.terms[0].exponent % 2 == 0) || p.terms[0].exponent % 2 != 0) \{\par
595 \par
596                 {\cf20 // Apply power difference factoring}\par
597                 powerDiffFactoring(p);\par
598 \par
599                 {\cf20 // Apply complex factorization if needed}\par
600                 {\cf19 if} (check_coefficient == 1) complexp(p);\par
601 \par
602                 printf({\cf22 ";\\n\\n"});\par
603                 {\cf19 return};\par
604             \}\par
605         \}\par
606 \par
607         {\cf20 // Apply Bhaskara's method if the polynomial has an even degree and 3 or fewer terms}\par
608         {\cf19 if} (p.terms[0].exponent % 2 == 0 && p.num_of_terms < 5 && p.terms[1].exponent != 3) \{\par
609 \par
610             bhaskara(p);\par
611 \par
612             printf({\cf22 ";\\n\\n"});\par
613             {\cf19 return};\par
614         \}\par
615 \par
616         {\cf20 // Apply Briot-Ruffini's method for non-unique coefficients}\par
617         {\cf19 if} (check_coefficient != 1) briot_ruffini(p);\par
618 \par
619         {\cf20 // Apply complex factorization if needed}\par
620         {\cf19 if} (check_coefficient == 1)\{\par
621 \par
622             complexp(p);\par
623             printf({\cf22 ";\\n\\n"});\par
624         \}\par
625 \par
626         {\cf19 return};\par
627     \}\par
628 \}\par
}
}
{\xe \v setTerms\:polynomialsz.c}
{\xe \v polynomialsz.c\:setTerms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b term} setTerms (int coef, int exp)}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates and sets the coefficient and exponent of a polynomial term. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i coef} \cell }{The coefficient of the term. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i exp} \cell }{The expoent of the term. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
T The complete term. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22                                  \{\par
23 \par
24     term T;\par
25     T.coefficient = coef;\par
26     T.exponent = exp;\par
27 \par
28     {\cf19 return} T;\par
29 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v var\:polynomialsz.c}
{\xe \v polynomialsz.c\:var}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char var = 'x'}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The symbolic variable used to represent roots and polynomial expressions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global symbolic variable used in polynomial expressions.\par
This variable is initialized with 'x' by default, but can be changed as needed. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/polynomialsz.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/polynomialsz.h}
{\xe \v C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/polynomialsz.h}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for polynomial factorization structures. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <math.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sterm}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b spolynomial}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _USE_MATH_DEFINES}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b sterm} {\b term}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b spolynomial} {\b polynomial}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b term} {\b setTerms} (int coef, int exp)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates and sets the coefficient and exponent of a polynomial term. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b nrt} (double rad, int ind)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the base of a power with an exponent equal to ind, which equals to rad. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b indOfRoot} (int rad, double rt)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the exponent (index) of a power that has base rt and result rad. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b polynomial} {\b pCreate} (int num_of_terms)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates and returns a polynomial with a specified number of terms. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pPrint} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the polynomial. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gcd} (int a, int b)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the greatest common divisor (GCD) of two integers using the Euclidean algorithm. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isPrime} (int num)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the n-th isPrime number, where n is less than or equal to 41. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b eisenstein} ({\b polynomial} x, double p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies Eisenstein's criterion to determine whether a polynomial is irreducible. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b complexp} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all non-real complex roots of a polynomial, assuming unit modulus. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b bhaskaraSimplify} (int aexp, int den, int b, double delta, double *rootsPair)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates a symbolic factorized string representation of a second-degree polynomial. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b bhaskara} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates and prints the factorization of a second-degree polynomial using the Bhaskara (quadratic) formula. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b powerDiffFactoring} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the sum or difference of powers identity (a^n \'B1 b^n). For odd n, both sum and difference can be factorized. For even n, only the difference can be factorized. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b briot_ruffini} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to factor a polynomial using the Rational Root Theorem and synthetic division. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printFac} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the factorization of a polynomial or displays the appropriate message based on the type of factorization that can be performed on it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pFree} ({\b polynomial} p)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unlike {\f2 {\b printFac()}} , this alternative also deallocates the polynomial's terms memory using {\f2 free(p.terms)} . }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b var}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global symbolic variable used in polynomial expressions. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for polynomial factorization structures. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file provides the necessary data structures and declarations used by the polynomial factorization algorithm, which supports:{
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Eisenstein's Criterion\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Briot-Ruffini (synthetic division)\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Bhaskara's method (quadratic formula)\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Power difference factoring\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Complex root analysis\par}
\par
The algorithm works with polynomials with integer coefficients.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Author\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Isaque Passos \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Version\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
1.0.0 Initial public release. Internal versions and tests existed prior to this. \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _USE_MATH_DEFINES\:polynomialsz.h}
{\xe \v polynomialsz.h\:_USE_MATH_DEFINES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _USE_MATH_DEFINES}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Required for mathematical operations. Enables use of M_PI and other constants in some compilers. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v polynomial\:polynomialsz.h}
{\xe \v polynomialsz.h\:polynomial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b spolynomial} polynomial}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v term\:polynomialsz.h}
{\xe \v polynomialsz.h\:term}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b sterm} term}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bhaskara\:polynomialsz.h}
{\xe \v polynomialsz.h\:bhaskara}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void bhaskara ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates and prints the factorization of a second-degree polynomial using the Bhaskara (quadratic) formula. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function simplifies the result depending on the values \'E2\'80\'8B\'E2\'80\'8Bof "b" and delta.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{A polynomial of degree 2 or 4 with three terms in descending order of exponent. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 351                             \{\par
352 \par
353     {\cf18 int} aexp = p.terms[0].exponent;\par
354     {\cf18 int} a = p.terms[0].coefficient;\par
355     {\cf18 int} b = p.terms[1].coefficient;\par
356     {\cf18 int} c = p.terms[2].coefficient;\par
357 \par
358     {\cf18 int} den = 2 * a;\par
359     {\cf18 double} delta = pow(b, 2) - (4 * a * c);\par
360     {\cf18 double} rootsPair[2] = \{0, 0\};\par
361 \par
362     rootsPair[0] = (-b + (sqrt((fabs)(delta)))) / den;\par
363     rootsPair[1] = (-b - (sqrt((fabs)(delta)))) / den;\par
364 \par
365     {\cf18 int} asbRoot1 = (int)(fabs)(rootsPair[0]);\par
366     {\cf18 int} asbRoot2 = (int)(fabs)(rootsPair[1]);\par
367 \par
368     {\cf18 char}* bSimplify = bhaskaraSimplify(aexp, den, b, delta, rootsPair);\par
369 \par
370     {\cf18 int} negRoot = (rootsPair[0] <= 0 || rootsPair[1] <= 0 || (aexp == 4 && delta >= 0)) ? 1 : -1;\par
371 \par
372     {\cf19 if}(negRoot == 1)\{\par
373 \par
374         printf({\cf22 "%s"}, bSimplify);\par
375     \}\par
376     {\cf19 else} {\cf19 if}(aexp == 4)\{\par
377 \par
378         printf({\cf22 "(%c%c%i)(%c%c%i)(%c%c%i)(%c%c%i)"}, var, (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, asbRoot1,\par
379                                                    var, (rootsPair[0] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, asbRoot1,\par
380                                                    var, (rootsPair[1] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, asbRoot2,\par
381                                                    var, (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, asbRoot2);\par
382     \}\par
383     {\cf19 else}\{\par
384 \par
385         printf({\cf22 "(%c%c%i)(%c%c%i)"}, var, (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, asbRoot1,\par
386                                    var, (rootsPair[1] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, asbRoot2);\par
387     \}\par
388 \par
389     free(bSimplify);\par
390 \}\par
}
}
{\xe \v bhaskaraSimplify\:polynomialsz.h}
{\xe \v polynomialsz.h\:bhaskaraSimplify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * bhaskaraSimplify (int aexp, int den, int b, double delta, double * rootsPair)}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates a symbolic factorized string representation of a second-degree polynomial. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function receives the coefficients and discriminant of a quadratic equation and returns a heap-allocated string with a symbolic factorization of its roots. It handles various cases, including:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Real and rational roots\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Irrational roots (containing square roots)\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Complex conjugate roots\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Pure imaginary roots\par}
It also supports optional squaring of the variable (e.g., x^2) if the polynomial is a square of a quadratic term (useful for degree 4 cases).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The returned string is dynamically allocated using {\f2 malloc()}  and must be freed by the caller to avoid memory leaks.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i aexp} \cell }{The exponent of the leading term (typically 2 or 4). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i den} \cell }{The denominator used to normalize the roots (usually 2 * a). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{The coefficient of the linear term in the polynomial. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i delta} \cell }{The discriminant value (b\'B2 - 4ac) of the polynomial. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rootsPair} \cell }{A pointer to an array of two doubles representing the numeric roots (used for formatting).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to a dynamically allocated string containing the symbolic factorization. The string must be freed manually by the caller. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 239                                                                                  \{\par
240 \par
241     {\cf18 int} absDelta = (int)(fabs)(delta);\par
242     {\cf18 char}* bSimplify = malloc({\cf17 sizeof}({\cf18 char}) * 60);\par
243     {\cf18 char} powerRoot[3] = {\cf22 ""};\par
244 \par
245     {\cf19 if}(aexp == 4)\{\par
246 \par
247         snprintf(powerRoot, 3, {\cf22 "^2"});\par
248     \}\par
249 \par
250     {\cf19 if}(({\cf18 int})sqrt(absDelta) * ({\cf18 int})sqrt(absDelta) == absDelta)\{\par
251 \par
252         {\cf19 if}(delta >= 0)\{\par
253 \par
254             {\cf19 if}((-b + ({\cf18 int})sqrt(absDelta)) % den == 0)\{\par
255 \par
256                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c %i)(%c%s %c %i)"}, var, powerRoot,\par
257                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, (-b + ({\cf18 int})sqrt(absDelta))/den, var, powerRoot,\par
258                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, (-b + ({\cf18 int})sqrt(absDelta))/den);\par
259             \}\par
260             {\cf19 else} {\cf19 if}((-b + ({\cf18 int})sqrt(absDelta)) % den != 0 && b != 0)\{\par
261 \par
262                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i + %i)/%i)(%c%s %c (%i - %i)/%i)"}, var, powerRoot,\par
263                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b, ({\cf18 int})sqrt(absDelta), den, var, powerRoot,\par
264                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b, ({\cf18 int})sqrt(absDelta), den);\par
265             \}\par
266             {\cf19 else}\{\par
267 \par
268                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i/%i))(%c%s %c (%i/i))"}, var, powerRoot,\par
269                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, ({\cf18 int})sqrt(absDelta), den, var, powerRoot,\par
270                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, ({\cf18 int})sqrt(absDelta), den);\par
271             \}\par
272         \}\par
273         {\cf19 else}\{\par
274             {\cf19 if}(-b % den == 0 && ({\cf18 int})sqrt(absDelta) % den == 0 && ({\cf18 int})sqrt(absDelta) / den != 1 && b != 0)\{\par
275 \par
276                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i + i%i))(%c%s %c (%i - i%i))"}, var, powerRoot,\par
277                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b/den, ({\cf18 int})sqrt(absDelta)/den, var, powerRoot,\par
278                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b/den, ({\cf18 int})sqrt(absDelta)/den);\par
279             \}\par
280             {\cf19 else} {\cf19 if}(-b % den == 0 && ({\cf18 int})sqrt(absDelta) % den == 0 && b != 0)\{\par
281 \par
282                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i + i))(%c%s %c (%i - i))"}, var, powerRoot,\par
283                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b/den, var, powerRoot,\par
284                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b/den);\par
285             \}\par
286 \par
287             {\cf19 else} {\cf19 if}(-b % den != 0 || ({\cf18 int})sqrt(absDelta) % den != 0 && b != 0)\{\par
288 \par
289                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i + i%i)/%i)(%c%s %c (%i - i%i)/%i)"}, var, powerRoot,\par
290                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b, ({\cf18 int})sqrt(absDelta), den, var, powerRoot,\par
291                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b, ({\cf18 int})sqrt(absDelta), den);\par
292             \}\par
293             {\cf19 else} {\cf19 if}(({\cf18 int})sqrt(absDelta) % den == 0 && ({\cf18 int})sqrt(absDelta) / den != 1 && b == 0)\{\par
294 \par
295                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c i%i)(%c%s %c i%i)"}, var, powerRoot,\par
296                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, ({\cf18 int})sqrt(absDelta)/den, var, powerRoot,\par
297                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, ({\cf18 int})sqrt(absDelta)/den);\par
298             \}\par
299             {\cf19 else} {\cf19 if}(({\cf18 int})sqrt(absDelta) % den == 0 && b == 0)\{\par
300 \par
301                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c i)(%c%s %c i)"}, var, powerRoot,\par
302                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, var, powerRoot,\par
303                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'});\par
304             \}\par
305             {\cf19 else}\{\par
306 \par
307                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c i%i/%i)(%c%s %c i%i/%i)"}, var, powerRoot,\par
308                (-b + absDelta >= 0) ? {\cf23 '-'} : {\cf23 '+'}, ({\cf18 int})sqrt(absDelta), den, var, powerRoot,\par
309                (-b + absDelta >= 0) ? {\cf23 '+'} : {\cf23 '-'}, ({\cf18 int})sqrt(absDelta), den);\par
310             \}\par
311         \}\par
312     \}\par
313     {\cf19 else}\{\par
314         {\cf19 if}(delta >= 0)\{\par
315 \par
316             {\cf19 if}(b != 0)\{\par
317 \par
318                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c ((%i + %i^\{1/2\})/%i)) (%c%s %c ((%i - %i^\{1/2\})/%i))"}, var, powerRoot,\par
319                (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b, absDelta, den, var, powerRoot,\par
320                (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b, absDelta, den);\par
321             \}\par
322             {\cf19 else}\{\par
323 \par
324                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (%i^\{1/2\})/%i) (%c%s %c (%i^\{1/2\})/%i)"}, var, powerRoot,\par
325                (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, absDelta, den, var, powerRoot,\par
326                (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, absDelta, den);\par
327             \}\par
328         \}\par
329         {\cf19 else}\{\par
330 \par
331             {\cf19 if}(b != 0)\{\par
332 \par
333                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c ((%i + i%i^\{1/2\})/%i)) (%c%s %c ((%i - i%i^\{1/2\})/%i))"}, var, powerRoot,\par
334                (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, -b, absDelta, den, var, powerRoot,\par
335                (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, -b, absDelta, den);\par
336             \}\par
337             {\cf19 else}\{\par
338 \par
339                 snprintf(bSimplify, 60, {\cf22 "(%c%s %c (i%i^\{1/2\})/%i) (%c%s %c (i%i^\{1/2\})/%i)"}, var, powerRoot,\par
340                (rootsPair[0] >= 0) ? {\cf23 '-'} : {\cf23 '+'}, absDelta, den, var, powerRoot,\par
341                (rootsPair[1] >= 0) ? {\cf23 '+'} : {\cf23 '-'}, absDelta, den);\par
342             \}\par
343         \}\par
344     \}\par
345 \par
346     {\cf19 return} bSimplify;\par
347 \}\par
}
}
{\xe \v briot_ruffini\:polynomialsz.h}
{\xe \v polynomialsz.h\:briot_ruffini}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void briot_ruffini ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Attempts to factor a polynomial using the Rational Root Theorem and synthetic division. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies Briot\'96Ruffini's method (synthetic division) to find integer and rational roots of a polynomial, as well as approximated square root roots when possible. Displays factored linear and radical terms.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial to be factored. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 433                                 \{\par
434 \par
435     {\cf18 int} max_num = 0, start = 1, i = 1, r = 1, rq = 0, end_int = 0, rnum = 1, rI = 1, cont = 1;\par
436     {\cf18 double} ind = 1, startf = 1;\par
437 \par
438     {\cf18 int} *root = ({\cf18 int}*)calloc(p.num_of_terms, {\cf17 sizeof}({\cf18 int}));\par
439 \par
440     {\cf19 for} ({\cf18 int} j = 1; j < p.num_of_terms; j++) \{\par
441         max_num = (p.terms[j].coefficient > max_num) ? p.terms[j].coefficient : max_num;\par
442     \}\par
443 \par
444     {\cf19 while} (i != max_num) \{\par
445 \par
446         start = i * 1 + p.terms[1].coefficient;\par
447 \par
448         {\cf19 for} ({\cf18 int} k = 2; k < p.num_of_terms; k++) \{\par
449             start = i * start + p.terms[k].coefficient;\par
450         \}\par
451 \par
452         {\cf19 if} (start == 0) \{\par
453             root[r] = i;\par
454             r++;\par
455         \}\par
456 \par
457         i++;\par
458     \}\par
459 \par
460     {\cf19 if} (r < p.num_of_terms) \{\par
461         i = -max_num;\par
462 \par
463         {\cf19 while} (i != 0) \{\par
464             start = i * 1 + p.terms[1].coefficient;\par
465 \par
466             {\cf19 for} ({\cf18 int} k = 2; k < p.num_of_terms; k++) \{\par
467                 start = i * start + p.terms[k].coefficient;\par
468             \}\par
469 \par
470             {\cf19 if} (start == 0) \{\par
471                 root[r] = i;\par
472                 r++;\par
473             \}\par
474 \par
475             i++;\par
476         \}\par
477     \}\par
478 \par
479     end_int = r;\par
480 \par
481     {\cf19 if} (r < p.num_of_terms) \{\par
482         rq = 2;\par
483 \par
484         {\cf19 while} (rq < max_num && r < p.num_of_terms) \{\par
485 \par
486             ind = sqrt(rq);\par
487             startf = ind + p.terms[1].coefficient;\par
488 \par
489             {\cf19 for} ({\cf18 int} k = 2; k <= p.num_of_terms; k++) \{\par
490                 startf = ind * startf + p.terms[k].coefficient;\par
491 \par
492                 {\cf19 if} (({\cf18 int})(startf * 1000) == 0) \{\par
493                     root[r] = rq;\par
494                     root[r + 1] = rq;\par
495                     r += 2;\par
496                     {\cf19 break};\par
497                 \}\par
498             \}\par
499 \par
500             rq++;\par
501 \par
502             {\cf19 for} ({\cf18 int} rr = 0; rr < end_int; rr++) \{\par
503                 {\cf19 if}(root[rr] == sqrt(rq)) \{\par
504                     rq++;\par
505                 \}\par
506             \}\par
507         \}\par
508     \}\par
509 \par
510     {\cf18 int} pr = 0;\par
511 \par
512     {\cf19 if} (r != p.num_of_terms-1) \{\par
513         {\cf19 for} ({\cf18 int} l = 1; root[l] != 0 && l < p.num_of_terms; l++) \{\par
514 \par
515             {\cf19 if} (l < end_int) \{\par
516                 printf({\cf22 "(%c%c%d)"}, var, ((root[l] > 0) ? {\cf23 '-'} : {\cf23 '+'}), abs(root[l]));\par
517                 pr++;\par
518             \}\par
519             {\cf19 else} {\cf19 if} (l >= end_int && p.terms[0].exponent != 3) \{\par
520                 printf({\cf22 "(%c + %d^\{1/2\})(%c - %d^\{1/2\})"}, var, root[l], var, root[l]);\par
521                 l++;\par
522                 pr++;\par
523             \}\par
524             {\cf19 if} (rq > 0 && p.terms[0].exponent % 2 != 0 && p.terms[0].exponent < 6 && (p.terms[p.num_of_terms - 1].coefficient >= 0))\{\par
525 \par
526                 {\cf18 int} px = (p.terms[0].exponent == 3) ? p.terms[1].coefficient + root[1] : p.terms[3].coefficient / -root[1];\par
527                 {\cf18 int} qx = (p.terms[0].exponent == 3) ? p.terms[2].coefficient + px*root[1] : p.terms[5].coefficient / -root[1];\par
528 \par
529                 polynomial aux = pCreate(3);\par
530                 aux.terms[0] = setTerms(1, p.terms[0].exponent - 1);\par
531                 aux.terms[1] = setTerms(px, p.terms[0].exponent / 2);\par
532                 aux.terms[2] = setTerms(qx, 0);\par
533 \par
534                 bhaskara(aux);\par
535                 printf({\cf22 "\\n\\n"});\par
536                 {\cf19 return};\par
537             \}\par
538         \}\par
539     \}\par
540 \par
541     {\cf19 if}(pr == 0)\{\par
542 \par
543         printf({\cf22 "There is no non-imaginary factorization and/or no root representable by radicals or integers for this polynomial.\\n\\n"});\par
544         free(root);\par
545         {\cf19 return};\par
546     \}\par
547 \par
548     printf({\cf22 ";\\n\\n"});\par
549     free(root);\par
550     {\cf19 return};\par
551 \}\par
}
}
{\xe \v complexp\:polynomialsz.h}
{\xe \v polynomialsz.h\:complexp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void complexp ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints all non-real complex roots of a polynomial, assuming unit modulus. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function assumes that the polynomial has only complex roots located on the unit circle and calculates the complex roots in exponential form e^\{i\'CE\'B8\} and e^\{-i\'CE\'B8\}, where \'CE\'B8 is an angle in radians represented as a multiple of \'CF\'80. It handles both cases when the polynomial is monic or not and adjusts the number of printed roots accordingly.\par
The roots are displayed using Euler's formula and shown as factorized expressions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial from which the complex roots will be extracted and printed. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 150                             \{\par
151 \par
152     {\cf18 double} angle = 0;\par
153     {\cf18 int} numerator = 0;\par
154     {\cf18 int} den = 1;\par
155 \par
156     {\cf19 for}({\cf18 int} l = 0; l < p.num_of_terms; l++)\{\par
157 \par
158         den *= p.terms[l].coefficient;\par
159     \}\par
160 \par
161     {\cf18 int} degree = (den == 1) ? p.num_of_terms : p.terms[0].exponent;\par
162 \par
163     {\cf18 int} total_roots = (degree % 2 == 0) ? degree - 1 : degree;\par
164 \par
165     {\cf19 if}(den != 1) total_roots++;\par
166 \par
167     {\cf18 int} common_divisor = 0;\par
168 \par
169     {\cf19 if} (degree % 2 == 0) \{\par
170         printf({\cf22 "(%c + 1)"}, var);\par
171     \}\par
172 \par
173     {\cf19 if} (den == 1)\{\par
174 \par
175         {\cf19 for} ({\cf18 int} k = 1; k <= total_roots / 2; k++) \{\par
176 \par
177             den = degree;\par
178             angle = 2 * M_PI * k / degree;\par
179             numerator = 2 * k;\par
180             common_divisor = gcd(numerator, den);\par
181 \par
182             numerator /= common_divisor;\par
183             den /= common_divisor;\par
184 \par
185             {\cf18 char} angle_str[50];\par
186 \par
187             {\cf19 if} (den == 1)\{\par
188                 snprintf(angle_str, 50, {\cf22 "%i*pi"}, numerator);\par
189             \}\par
190             {\cf19 else} {\cf19 if} (numerator == 1)\{\par
191                 snprintf(angle_str, 50, {\cf22 "*pi/%i"}, den);\par
192             \}\par
193             {\cf19 else}\{\par
194                 snprintf(angle_str, 50, {\cf22 "%i*pi/%i"}, numerator, den);\par
195             \}\par
196 \par
197             {\cf19 if}(den == 2 && numerator == 1)\{\par
198 \par
199                 printf({\cf22 "(%c - i)"}, var);\par
200                 printf({\cf22 "(%c + i)"}, var);\par
201                 {\cf19 return};\par
202             \}\par
203 \par
204             printf({\cf22 "(%c - e^\{i%s\})"}, var, angle_str);\par
205             printf({\cf22 "(%c - e^\{-i%s\})"}, var, angle_str);\par
206         \}\par
207     \}\par
208     {\cf19 else}\{\par
209 \par
210         {\cf19 for} ({\cf18 int} k = 0; k < p.terms[0].exponent; k++) \{\par
211 \par
212             den = degree;\par
213             numerator = (2 * k) + 1;\par
214             common_divisor = gcd(numerator, den);\par
215 \par
216             numerator /= common_divisor;\par
217             den /= common_divisor;\par
218 \par
219             {\cf18 char} angle_str[50];\par
220 \par
221             {\cf19 if} (den == 1)\{\par
222                 snprintf(angle_str, 50, {\cf22 "%i*pi"}, numerator);\par
223             \}\par
224             {\cf19 else} {\cf19 if} (numerator == 1)\{\par
225                 snprintf(angle_str, 50, {\cf22 "*pi/%i"}, den);\par
226             \}\par
227             {\cf19 else}\{\par
228                 snprintf(angle_str, 50, {\cf22 "%i*pi/%i"}, numerator, den);\par
229             \}\par
230 \par
231             {\cf19 if}(numerator != den) printf({\cf22 "(%c - e^\{i%s\})"}, var, angle_str);\par
232             {\cf19 else} printf({\cf22 "(%c + 1)"}, var);\par
233         \}\par
234     \}\par
235 \}\par
}
}
{\xe \v eisenstein\:polynomialsz.h}
{\xe \v polynomialsz.h\:eisenstein}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int eisenstein ({\b polynomial} x, double p)}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies Eisenstein's criterion to determine whether a polynomial is irreducible. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if the polynomial satisfies the conditions of Eisenstein's Criterion for irreducibility using the isPrime number p. According to the criterion, all coefficients except the leading one must be divisible by p, and the constant term must not be divisible by p^2.\par
Although Eisenstein's Criterion is a powerful tool, it has limitations \'97 for example, the polynomial (x^4 + 1) is irreducible over the rationals, despite not satisfying the criterion.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{The polynomial to be tested. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{A isPrime number used for the Eisenstein's test. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
1 if the polynomial is irreducible by Eisenstein's criterion, -1 otherwise. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 127                                       \{\par
128 \par
129     {\cf18 int} irr = 1;\par
130 \par
131     {\cf19 for}({\cf18 int} i = 1; i < x.num_of_terms; i++)\{\par
132 \par
133         irr = (x.terms[i].coefficient % (int)p == 0) ? irr * 1 : 0;\par
134     \}\par
135 \par
136     {\cf19 if}(x.terms[x.num_of_terms - 1].coefficient % ({\cf18 int})pow(p, 2) != 0)\par
137         irr *= 1;\par
138     {\cf19 else}\par
139         irr = 0;\par
140 \par
141 \par
142     {\cf19 if}(irr == 1)\par
143         {\cf19 return} 1;\par
144     {\cf19 else}\par
145         {\cf19 return} -1;\par
146 \}\par
}
}
{\xe \v gcd\:polynomialsz.h}
{\xe \v polynomialsz.h\:gcd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int gcd (int a, int b)}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the greatest common divisor (GCD) of two integers using the Euclidean algorithm. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i a} \cell }{The first integer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{The second integer. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The greatest common divisor of a and b. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 94                       \{\par
95 \par
96     {\cf19 if}(b == 0)\par
97         {\cf19 return} a;\par
98 \par
99     {\cf19 return} gcd(b, a % b);\par
100 \}\par
}
}
{\xe \v indOfRoot\:polynomialsz.h}
{\xe \v polynomialsz.h\:indOfRoot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int indOfRoot (int rad, double rt)}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the exponent (index) of a power that has base rt and result rad. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rad} \cell }{The radicand (power's result). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rt} \cell }{The root (power's base). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
ind The index (power's exponent). \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 42                                  \{\par
43 \par
44     {\cf18 int} ind = 1;\par
45 \par
46     {\cf19 while}(({\cf18 int})pow(rt, ind) != (fabs)(rad))\{\par
47         ind++;\par
48     \}\par
49 \par
50     {\cf19 return} ind;\par
51 \}\par
}
}
{\xe \v isPrime\:polynomialsz.h}
{\xe \v polynomialsz.h\:isPrime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int isPrime (int num)}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the n-th isPrime number, where n is less than or equal to 41. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function only supports values of n up to 41 because the 41st isPrime number is 179, which is the largest isPrime whose square (179^2 = 32,041) still fits within a 32-bit signed integer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The position of the isPrime number to return (must be \'E2\'89\'A4 41). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The n-th isPrime number, or 0 if num > 41. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103                     \{\par
104 \par
105     {\cf19 if}(num > 41)\par
106         {\cf19 return} 0;\par
107 \par
108     {\cf18 int} i = 2;\par
109     {\cf18 int} pcont = 0;\par
110     {\cf18 int} dcont = 0;\par
111 \par
112     {\cf19 for}(i = 2; i < 180 && pcont != num; i++)\{\par
113 \par
114         {\cf19 for}({\cf18 int} k = 1; k <= i; k++)\{\par
115 \par
116             dcont = (i % k == 0) ? dcont + 1 : dcont;\par
117         \}\par
118         pcont = (dcont == 2) ? pcont + 1 : pcont;\par
119         dcont = 0;\par
120     \}\par
121 \par
122     {\cf19 return} i - 1;\par
123 \}\par
}
}
{\xe \v nrt\:polynomialsz.h}
{\xe \v polynomialsz.h\:nrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double nrt (double rad, int ind)}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the base of a power with an exponent equal to ind, which equals to rad. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rad} \cell }{The radicand (power's result). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ind} \cell }{The index (power's exponent). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
base The base (radical's result). \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 33                                \{\par
34 \par
35     {\cf18 double} base = (pow((fabs)(rad), 1.0/({\cf18 double})(ind)));\par
36 \par
37     {\cf19 return} base;\par
38 \}\par
}
}
{\xe \v pCreate\:polynomialsz.h}
{\xe \v polynomialsz.h\:pCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b polynomial} pCreate (int num_of_terms)}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates and returns a polynomial with a specified number of terms. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function allocates memory for a polynomial structure and initializes its internal array of terms based on the specified number of terms. It is used as a starting point for defining or manipulating polynomials.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num_of_terms} \cell }{The number of terms the polynomial should contain. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A polynomial structure with allocated space for the specified number of terms. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 55                                      \{\par
56 \par
57     {\cf18 int} j = 0;\par
58     polynomial p;\par
59     p.num_of_terms = num_of_terms;\par
60     p.terms = (term*)malloc(num_of_terms * {\cf17 sizeof}(term));\par
61 \par
62     {\cf19 if}(p.terms == NULL)\{\par
63 \par
64         printf({\cf22 "\\nError allocating memory."});\par
65         {\cf19 return} p;\par
66     \}\par
67 \par
68     {\cf19 for}({\cf18 int} i = num_of_terms-1; i >= 0; i--)\{\par
69 \par
70         p.terms[j].coefficient = 0;\par
71         p.terms[j].exponent = i;\par
72         j++;\par
73     \}\par
74 \par
75     {\cf19 return} p;\par
76 \}\par
}
}
{\xe \v pFree\:polynomialsz.h}
{\xe \v polynomialsz.h\:pFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pFree ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unlike {\f2 {\b printFac()}} , this alternative also deallocates the polynomial's terms memory using {\f2 free(p.terms)} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial to be factored. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 632                          \{\par
633 \par
634     {\cf18 int} check_coefficient = (p.num_of_terms > 2 && p.terms[p.num_of_terms - 1].coefficient == 1) ? 1 : 0;\par
635 \par
636     {\cf19 for} ({\cf18 int} j = 0; j < p.num_of_terms; j++) \{\par
637         check_coefficient = ((p.terms[j].coefficient) == -1) ? (check_coefficient + 2) : check_coefficient;\par
638         check_coefficient = ((p.terms[j].coefficient) == 1) ? (check_coefficient * check_coefficient) : check_coefficient;\par
639     \}\par
640 \par
641     {\cf18 int} irrdcble = 0;\par
642 \par
643     {\cf19 for} ({\cf18 int} i = 1; i < 42 && irrdcble != 1; i++) \{\par
644         irrdcble = eisenstein(p, isPrime(i));\par
645     \}\par
646 \par
647     {\cf19 if} (irrdcble == 1 && p.num_of_terms >= 5 && ((p.num_of_terms % 2 == 0 && p.terms[p.num_of_terms - 1].coefficient > 0)\par
648         || p.num_of_terms % 2 != 0 && p.terms[p.num_of_terms - 1].coefficient < 0) || irrdcble == -1 && p.num_of_terms >= 5 && check_coefficient > 1)\{\par
649 \par
650         printf({\cf22 "There is no non-imaginary factorization and/or no root representable by radicals or integers for this polynomial.\\n\\n"});\par
651         free(p.terms);\par
652 \par
653         {\cf19 return};\par
654     \} {\cf19 else} \{\par
655 \par
656         {\cf19 if} (p.num_of_terms == 2 && p.terms[0].exponent == indOfRoot(p.terms[1].coefficient, (nrt(p.terms[1].coefficient, p.terms[0].exponent)))) \{\par
657 \par
658             {\cf19 if} ((p.terms[1].coefficient < 0 && p.terms[0].exponent % 2 == 0) || p.terms[0].exponent % 2 != 0) \{\par
659 \par
660                 powerDiffFactoring(p);\par
661 \par
662                 {\cf19 if} (check_coefficient == 1) complexp(p);\par
663 \par
664                 free(p.terms);\par
665 \par
666                 printf({\cf22 ";\\n\\n"});\par
667                 {\cf19 return};\par
668             \}\par
669         \}\par
670 \par
671         {\cf19 if} (p.terms[0].exponent % 2 == 0 && p.num_of_terms < 5 && p.terms[1].exponent != 3) \{\par
672 \par
673             bhaskara(p);\par
674 \par
675             free(p.terms);\par
676 \par
677             printf({\cf22 ";\\n\\n"});\par
678             {\cf19 return};\par
679         \}\par
680 \par
681         {\cf19 if} (check_coefficient != 1) briot_ruffini(p);\par
682 \par
683         {\cf19 if} (check_coefficient == 1)\{\par
684 \par
685             complexp(p);\par
686             printf({\cf22 ";\\n\\n"});\par
687         \}\par
688 \par
689         free(p.terms);\par
690 \par
691         {\cf19 return};\par
692     \}\par
693 \par
694     free(p.terms);\par
695 \}\par
}
}
{\xe \v powerDiffFactoring\:polynomialsz.h}
{\xe \v polynomialsz.h\:powerDiffFactoring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void powerDiffFactoring ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the sum or difference of powers identity (a^n \'B1 b^n). For odd n, both sum and difference can be factorized. For even n, only the difference can be factorized. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assumes the polynomial is in the form x^n \'B1 a and prints the factorization steps based on the formula. Handles both even and odd exponents.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial to be factored. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 394                                      \{\par
395 \par
396     {\cf18 int} i = p.terms[0].exponent - 1, even_num = 1;\par
397     {\cf18 int} count = 1;\par
398     {\cf18 double} a = (nrt(p.terms[1].coefficient, p.terms[0].exponent));\par
399 \par
400     printf({\cf22 "(%c%c%i)"}, var, (p.terms[1].coefficient < 0) ? {\cf23 '-'} : {\cf23 '+'}, ({\cf18 int})a);\par
401 \par
402     {\cf19 if}(p.terms[0].exponent % 2 == 0)\{\par
403         printf({\cf22 "(%c%c%i)"}, var, (p.terms[1].coefficient < 0) ? {\cf23 '+'} : {\cf23 '-'}, ({\cf18 int})a);\par
404         even_num++;\par
405     \}\par
406 \par
407     {\cf19 if}(p.terms[0].exponent < 2)\{\par
408         {\cf19 return};\par
409     \}\par
410 \par
411     printf({\cf22 "(%c^\{%i\}"}, var, (even_num == 2) ? --i : i);\par
412 \par
413     {\cf19 while}(i - even_num > 0)\{\par
414         printf({\cf22 " %c %i%c^\{%i\}"},\par
415                (p.terms[1].coefficient > 0 && i % 2 == 0) ? {\cf23 '-'} : {\cf23 '+'},\par
416                (even_num == 2) ? ({\cf18 int})(pow(a, ++count)) : ({\cf18 int})(pow(a, count++)),\par
417                var, i - even_num);\par
418 \par
419         {\cf19 if}(even_num == 2)\{\par
420             i = i - even_num;\par
421             count++;\par
422         \}\par
423         {\cf19 else} i--;\par
424     \}\par
425 \par
426     printf({\cf22 " + %i)"}, ({\cf18 int})(pow(a, p.terms[0].exponent - even_num)));\par
427 \par
428     {\cf19 return};\par
429 \}\par
}
}
{\xe \v pPrint\:polynomialsz.h}
{\xe \v polynomialsz.h\:pPrint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pPrint ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the polynomial. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 80                          \{\par
81 \par
82     printf({\cf22 "(%i%c^%i"}, p.terms[0].coefficient, var, p.terms[0].exponent);\par
83 \par
84     {\cf19 for}({\cf18 int} i = 1; i < p.num_of_terms; i++)\{\par
85 \par
86         printf({\cf22 "%c%i%c^%i"}, (p.terms[i].coefficient >= 0) ? {\cf23 '+'} : {\cf23 '-'}, (abs)(p.terms[i].coefficient), var, p.terms[i].exponent);\par
87     \}\par
88 \par
89     printf({\cf22 ")\\n\\n"});\par
90 \}\par
}
}
{\xe \v printFac\:polynomialsz.h}
{\xe \v polynomialsz.h\:printFac}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printFac ({\b polynomial} p)}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the factorization of a polynomial or displays the appropriate message based on the type of factorization that can be performed on it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function evaluates a polynomial to determine the appropriate factorization technique:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
If the polynomial is irreducible based on Eisenstein's criterion, it outputs a message indicating that there is no non-imaginary factorization or roots representable by radicals.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
If the polynomial is a quadratic, it applies potential difference factoring, if applicable.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
If the polynomial has an even degree and three or fewer terms, it applies the Bhaskara method.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
If the polynomial does not meet any of the above criteria, it attempts Briot-Ruffini's method or performs complex factorization if needed.\par}
The function handles polynomials with a varying number of terms and coefficients, including checking for special cases such as unique coefficients and evaluating Eisenstein's criterion.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The polynomial to be factored. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 555                             \{\par
556 \par
557     {\cf18 int} check_coefficient = (p.num_of_terms > 2 && p.terms[p.num_of_terms - 1].coefficient == 1) ? 1 : 0;\par
558 \par
559     {\cf19 for} ({\cf18 int} j = 0; j < p.num_of_terms; j++) \{\par
560         check_coefficient = ((p.terms[j].coefficient) == -1) ? (check_coefficient + 2) : check_coefficient;\par
561         check_coefficient = ((p.terms[j].coefficient) == 1) ? (check_coefficient * check_coefficient) : check_coefficient;\par
562     \}\par
563 \par
564     {\cf18 int} irrdcble = 0;\par
565 \par
566     {\cf19 for} ({\cf18 int} i = 1; i < 42 && irrdcble != 1; i++) \{\par
567         irrdcble = eisenstein(p, isPrime(i));\par
568     \}\par
569 \par
570     {\cf20 /*}\par
571 {\cf20      * This condition checks if the polynomial meets one of two criteria:}\par
572 {\cf20      *}\par
573 {\cf20      * 1. The polynomial is irreducible, has 5 or more terms, and satisfies one of the following:}\par
574 {\cf20      *    - The highest degree is even, and the constant term (last coefficient) is positive.}\par
575 {\cf20      *    - The highest degree is odd, and the constant term is negative.}\par
576 {\cf20      *}\par
577 {\cf20      * 2. The polynomial is not irreducible (irrdcble == -1), has 5 or more terms, and its coefficient check value (check_coefficient) is greater than 1.}\par
578 {\cf20      *    This implies the polynomial may not follow a simple factorization or progression pattern.}\par
579 {\cf20      *}\par
580 {\cf20      * If either of these conditions is met, the function prints a message indicating that}\par
581 {\cf20      * no non-imaginary factorization and/or no root representable by radicals or integers}\par
582 {\cf20      * is possible for the polynomial, and the function returns.}\par
583 {\cf20      */}\par
584     {\cf19 if} (irrdcble == 1 && p.num_of_terms >= 5 && ((p.num_of_terms % 2 == 0 && p.terms[p.num_of_terms - 1].coefficient > 0)\par
585         || p.num_of_terms % 2 != 0 && p.terms[p.num_of_terms - 1].coefficient < 0) || irrdcble == -1 && p.num_of_terms >= 5 && check_coefficient > 1)\{\par
586 \par
587         printf({\cf22 "There is no non-imaginary factorization and/or no root representable by radicals or integers for this polynomial.\\n\\n"});\par
588 \par
589         {\cf19 return};\par
590     \} {\cf19 else} \{\par
591         {\cf20 // Handle case for a quadratic polynomial}\par
592         {\cf19 if} (p.num_of_terms == 2 && p.terms[0].exponent == indOfRoot(p.terms[1].coefficient, (nrt(p.terms[1].coefficient, p.terms[0].exponent)))) \{\par
593 \par
594             {\cf19 if} ((p.terms[1].coefficient < 0 && p.terms[0].exponent % 2 == 0) || p.terms[0].exponent % 2 != 0) \{\par
595 \par
596                 {\cf20 // Apply power difference factoring}\par
597                 powerDiffFactoring(p);\par
598 \par
599                 {\cf20 // Apply complex factorization if needed}\par
600                 {\cf19 if} (check_coefficient == 1) complexp(p);\par
601 \par
602                 printf({\cf22 ";\\n\\n"});\par
603                 {\cf19 return};\par
604             \}\par
605         \}\par
606 \par
607         {\cf20 // Apply Bhaskara's method if the polynomial has an even degree and 3 or fewer terms}\par
608         {\cf19 if} (p.terms[0].exponent % 2 == 0 && p.num_of_terms < 5 && p.terms[1].exponent != 3) \{\par
609 \par
610             bhaskara(p);\par
611 \par
612             printf({\cf22 ";\\n\\n"});\par
613             {\cf19 return};\par
614         \}\par
615 \par
616         {\cf20 // Apply Briot-Ruffini's method for non-unique coefficients}\par
617         {\cf19 if} (check_coefficient != 1) briot_ruffini(p);\par
618 \par
619         {\cf20 // Apply complex factorization if needed}\par
620         {\cf19 if} (check_coefficient == 1)\{\par
621 \par
622             complexp(p);\par
623             printf({\cf22 ";\\n\\n"});\par
624         \}\par
625 \par
626         {\cf19 return};\par
627     \}\par
628 \}\par
}
}
{\xe \v setTerms\:polynomialsz.h}
{\xe \v polynomialsz.h\:setTerms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b term} setTerms (int coef, int exp)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates and sets the coefficient and exponent of a polynomial term. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i coef} \cell }{The coefficient of the term. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i exp} \cell }{The expoent of the term. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
T The complete term. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22                                  \{\par
23 \par
24     term T;\par
25     T.coefficient = coef;\par
26     T.exponent = exp;\par
27 \par
28     {\cf19 return} T;\par
29 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v var\:polynomialsz.h}
{\xe \v polynomialsz.h\:var}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char var{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global symbolic variable used in polynomial expressions. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This variable is used for displaying polynomial roots symbolically. For example, if var = 'x', the roots of x\'C2\'B2 - 2 are printed as x + \'E2\'88\'9A2 and x - \'E2\'88\'9A2.\par
Global symbolic variable used in polynomial expressions.\par
This variable is initialized with 'x' by default, but can be changed as needed. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
polynomialsz.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/polynomialsz.h}
{\xe \v C:/Users/isaqu/Desktop/Outroam/UESC/polynomialsz/Algoritmo/v1.0.0/polynomialsz.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef POLYNOMIALSZ_H_INCLUDED}\par
2 {\cf21 #define POLYNOMIALSZ_H_INCLUDED}\par
3 \par
22 \par
23 {\cf21 #include <stdio.h>}\par
24 {\cf21 #include <stdlib.h>}\par
25 {\cf21 #include <math.h>} \par
26 \par
27 {\cf21 #define _USE_MATH_DEFINES }{\cf21 }\par
28 \par
35 {\cf17 extern} {\cf18 char} var;\par
36 \par
44 {\cf17 typedef} {\cf17 struct }sterm \{\par
45     {\cf18 int} coefficient; \par
46     {\cf18 int} exponent;    \par
47 \} term;\par
48 \par
55 {\cf17 typedef} {\cf17 struct }spolynomial \{\par
56     term *terms;        \par
57     {\cf18 int} num_of_terms;   \par
58 \} polynomial;\par
59 \par
60 {\cf20 //-----------------------------------------------------------------------------}\par
68 term setTerms({\cf18 int} coef, {\cf18 int} exp);\par
69 {\cf20 //-----------------------------------------------------------------------------}\par
77 {\cf18 double} nrt({\cf18 double} rad, {\cf18 int} ind);\par
78 {\cf20 //-----------------------------------------------------------------------------}\par
86 {\cf18 int} indOfRoot({\cf18 int} rad, {\cf18 double} rt);\par
87 {\cf20 //-----------------------------------------------------------------------------}\par
98 polynomial pCreate({\cf18 int} num_of_terms);\par
99 {\cf20 //-----------------------------------------------------------------------------}\par
105 {\cf18 void} pPrint(polynomial p);\par
106 {\cf20 //-----------------------------------------------------------------------------}\par
114 {\cf18 int} gcd({\cf18 int} a, {\cf18 int} b);\par
115 {\cf20 //-----------------------------------------------------------------------------}\par
125 {\cf18 int} isPrime({\cf18 int} num);\par
126 {\cf20 //-----------------------------------------------------------------------------}\par
142 {\cf18 int} eisenstein(polynomial x, {\cf18 double} p);\par
143 {\cf20 //-----------------------------------------------------------------------------}\par
156 {\cf18 void} complexp(polynomial p);\par
157 {\cf20 //-----------------------------------------------------------------------------}\par
183 {\cf18 char}* bhaskaraSimplify({\cf18 int} aexp, {\cf18 int} den, {\cf18 int} b, {\cf18 double} delta, {\cf18 double}* rootsPair);\par
184 {\cf20 //-----------------------------------------------------------------------------}\par
194 {\cf18 void} bhaskara(polynomial p);\par
195 {\cf20 //-----------------------------------------------------------------------------}\par
206 {\cf18 void} powerDiffFactoring(polynomial p);\par
207 {\cf20 //-----------------------------------------------------------------------------}\par
216 {\cf18 void} briot_ruffini(polynomial p);\par
217 \par
218 {\cf20 //-----------------------------------------------------------------------------}\par
219 \par
237 {\cf18 void} printFac(polynomial p);\par
238 \par
239 {\cf20 //-----------------------------------------------------------------------------}\par
240 \par
247  {\cf18 void} pFree(polynomial p);\par
248 \par
249 {\cf21 #endif }{\cf20 // POLYNOMIALSZ_H_INCLUDED}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
